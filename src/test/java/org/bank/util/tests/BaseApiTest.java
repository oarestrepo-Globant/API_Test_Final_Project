package org.bank.util.tests;

import static io.restassured.RestAssured.*;
import static io.restassured.http.ContentType.JSON;

import com.github.javafaker.Faker;
import io.restassured.path.json.JsonPath;
import io.restassured.response.Response;
import org.apache.log4j.Logger;
import org.bank.models.Transaction;
import org.bank.util.RestAssuredUtil;
import org.testng.Assert;
import org.testng.annotations.*;

import java.util.*;

/**
 * Base test for API tests.
 * @author oscar.restrepo
 */
public class BaseApiTest extends RestAssuredUtil{
    protected Response response = null;
    protected static List<Transaction> allTransactions;
    public Logger log = Logger.getLogger(BaseApiTest.class);

    @DataProvider(name = "idTransaction")
    public Object[][] getUsersLoginData() {
        return new Object[][]{{"1"}};
    }

   /**
     * initializes the initial setUp before class.
    * @author oscar.restrepo
     * */
    @BeforeClass
    public void setup() {
        RestAssuredUtil.setBaseURI();
        RestAssuredUtil.setContentType(JSON);
    }

    /**
     * get all transaction before each  method.
     * @author oscar.restrepo
     * */
    @BeforeMethod
    public void beforeMethod() {
        allTransactions = getAllTransactions();
    }

    /**
     * delete all transactions after each method.
     * @author oscar.restrepo
     * */
    @AfterMethod
    public void afterMethod(){
        allTransactions = null;
    }

    /**
     * after class resets the baseURL and the basePath.
     * @author oscar.restrepo
     **/
    @AfterClass
    public void afterTest() {
        //Reset Values
        RestAssuredUtil.resetBaseURI();
        RestAssuredUtil.resetBasePath();
    }

    /**
     * Verify that the status code returned is equal to the expected status code.
     * @param statusCodeExpected:res
     * @author oscar.restrepo
     * */
    protected void assertStatusCode(Response res, int statusCodeExpected) {
        Assert.assertEquals(res.getStatusCode(), statusCodeExpected, "Status Check Failed!");
    }

    /**
     * get all transactions, deserialize JSON Array to List and return that list
     * @author oscar.restrepo
     * */
    protected  List<Transaction> getAllTransactions(){
        response = getResponse();
        JsonPath jsonPathEvaluator = response.jsonPath();

        List<Transaction> transactions = jsonPathEvaluator.getList("transactions", Transaction.class);

        this.allTransactions = transactions;
        return allTransactions;
    }

    /**
     * delete specific transaction by given id.
     *
     * @param id:int
     * @author oscar.restrepo
     * */
    protected void deleteTransaction(int id){
        Response response1 =
           deleteResponse(baseURI+id);

        response1.then().
                assertThat().
                statusCode(200);
    }

    /**
     * return true if there is data in the path /transactions, if it finds data it deletes it.
     * Otherwise, return false.
     *
     * @author oscar.restrepo
     * */
    protected boolean deleteAllTransactions(){

        if(allTransactions.size() != 0){

            allTransactions.forEach(transaction -> deleteTransaction(transaction.getId()));
        }

        response = deleteResponse(baseURI);
        allTransactions = getAllTransactions();
        return allTransactions.size() == 0;
    }

    /**
     * Make the GET request, asserting that there are not duplicate email accounts
     *
     * @return true if there are duplicate email accounts, otherwise return false.
     *
     * @author oscar.restrepo
     */
    protected boolean areDuplicateEmailsAccount() {
        List<String> emailsAccounts = new ArrayList<>();

        allTransactions = getAllTransactions();

        allTransactions.forEach(transaction -> {
            if(!emailsAccounts.contains(transaction.getEmail())){
                emailsAccounts.add(transaction.getEmail());
            }
        });

        return allTransactions.size() != emailsAccounts.size();
    }

    /**
     *@return a list of 10 Transaction instances with data generated by javaFaker
     * @author oscar.restrepo
     */
    protected ArrayList<Transaction> createTenRandomTransactions(){
        ArrayList<Transaction> newTransactions= new ArrayList<>();
        Faker fake = Faker.instance(Locale.forLanguageTag("en-US"));

        for (int i = 0; i < 10; i++) {
            newTransactions.add(new Transaction(
                    fake.name().firstName(),
                    fake.name().lastName(),
                    fake.number().numberBetween(100,9999999),
                    fake.number().randomDouble(2, 10, 100000000),
                    fake.options().option("invoice","withdrawal","deposit","payment"),
                    fake.internet().emailAddress(),
                    fake.random().nextBoolean(),
                    fake.country().name(),
                    fake.phoneNumber().phoneNumber()
            ));
        }
        return newTransactions;
    }

    /**
     * Verifies that there are no repeated emails in a Transaction list.
     * Performs a POST with the Transactions that do not have repeated mails
     *

     * @author oscar.restrepo
     */
    protected void postTransactions(){
        List<String> emailsAccounts = new ArrayList<>();
        List<Transaction> fakeTransaction = createTenRandomTransactions();

        fakeTransaction.forEach(transaction -> {
            if(!emailsAccounts.contains(transaction.getEmail())){
                emailsAccounts.add(transaction.getEmail());
                response = postResponse(baseURI, transaction);
                log.info("Post transaction in endpoint");
            }
        });
    }

    /**
     * update the account number of a specific transaction given a transaction id.
     *
     * @param idTransaction:int
     *
     * @author oscar.restrepo
     */
    protected void updateExistingAccountNumber(String idTransaction) {

        Faker fake = Faker.instance(Locale.forLanguageTag("en-US"));
        int newAccount = fake.number().numberBetween(10,9999999);

        Map<String, Integer> transaction = new HashMap<>();
        transaction.put("accountNumber", newAccount);

        response = putResponse(baseURI + idTransaction, transaction);
     }
}
